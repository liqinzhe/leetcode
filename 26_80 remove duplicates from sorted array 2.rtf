{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 TimesNewRomanPSMT;\f2\fnil\fcharset134 PingFangSC-Regular;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab420
\pard\pardeftab420\ri0\qj\partightenfactor0

\f0\fs24 \cf0 /*
\f1 \

\f0 Follow up for "Remove Duplicates":
\f1 \

\f0 What if duplicates are allowed at most twice?
\f1 \
\

\f0 For example,
\f1 \

\f0 Given sorted array nums = [1,1,1,2,2,3],
\f1 \
\

\f0 Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.
\f1 \
\

\f0 way-2:
\f2 \'c1\'bd\'b8\'f6\'d6\'b8\'d5\'eb
\f1 \
\

\f0 */
\f1 \

\f0 class Solution \{
\f1 \

\f0 public:
\f1 \

\f0     int removeDuplicates(vector<int>& nums) 
\f1 \

\f0     \{
\f1 \

\f0          int array_len = nums.size();\
        int first = 0;\
        int last;\
        while ( first < nums.size())\
        \{\
            if (first + 1 < nums.size() && nums[first+1] != nums[first])\
            \{\
                first++;\
                continue;\
            \}\
            \
            last = first + 2;\
            while (last < nums.size() && nums[last] == nums[first])\
            \{\
                nums.erase(nums.begin() + last);\
                array_len --;\
            \}\
            first = last;\
        \}\
        return array_len;
\f1 \

\f0     \}
\f1 \

\f0 \};
\f1 \
}