{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Given inorder and postorder traversal of a tree, construct the binary tree.\
\
Note:\
You may assume that duplicates do not exist in the tree.\
\
\
*/\
/**\
 * Definition for a binary tree node.\
 * struct TreeNode \{\
 *     int val;\
 *     TreeNode *left;\
 *     TreeNode *right;\
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) \{\}\
 * \};\
 */\
class Solution \{\
public:\
    \
    TreeNode* guocheng(vector<int> &inorder,int begin1,int end1, vector<int> &postorder,int begin2,int end2)\
    \{\
        if(begin2>end2)\
            return NULL; \
        else if(begin2==end2)        \
            return new TreeNode(postorder[end2]);\
            \
        TreeNode *p=new TreeNode(postorder[end2]);\
        \
        int lenleft=find(inorder.begin(),inorder.end(),postorder[end2])-inorder.begin()-begin1;\
        p->left=guocheng(inorder,begin1,begin1+lenleft-1,postorder,begin2,begin2+lenleft-1);\
        p->right=guocheng(inorder,begin1+lenleft+1,end1,postorder,begin2+lenleft,end2-1);\
        \
        return p;\
    \}\
    \
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \
    \{\
        return guocheng(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1);\
    \}\
\};\
\
\
    \
}