{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.\
\
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\
\
House Robber I
\f1 \'b5\'c4\'c9\'fd\'bc\'b6\'b0\'e6
\f0 . \

\f1 \'d2\'f2\'ce\'aa\'b5\'da\'d2\'bb\'b8\'f6
\f0 element 
\f1 \'ba\'cd\'d7\'ee\'ba\'f3\'d2\'bb\'b8\'f6
\f0 element
\f1 \'b2\'bb\'c4\'dc\'cd\'ac\'ca\'b1\'b3\'f6\'cf\'d6
\f0 . 
\f1 \'d4\'f2\'b7\'d6\'c1\'bd\'b4\'ce
\f0 call House Robber I. \
case 1: 
\f1 \'b2\'bb\'b0\'fc\'c0\'a8\'d7\'ee\'ba\'f3\'d2\'bb\'b8\'f6
\f0 element. \
case 2: 
\f1 \'b2\'bb\'b0\'fc\'c0\'a8\'b5\'da\'d2\'bb\'b8\'f6
\f0 element.\

\f1 \'c1\'bd\'d5\'df\'b5\'c4\'d7\'ee\'b4\'f3\'d6\'b5\'bc\'b4\'ce\'aa\'c8\'ab\'be\'d6\'d7\'ee\'b4\'f3\'d6\'b5
\f0 \
\
*/\
class Solution \{\
public:\
    \
    int rob1(vector<int> nums) \
    \{ \
        if(nums.size()==0)\
            return 0;\
        else if(nums.size()==1)\
            return nums[0];\
        else if(nums.size()==2)\
            return max(nums[0],nums[1]);\
        else if(nums.size()==3)\
            return max(nums[0]+nums[2],nums[1]);\
            \
        for(int i=2;i<nums.size();i++) \
        \{\
            nums[i]+=max(nums[i-2],nums[i-3]);\
        \}    \
        \
        return max(nums[nums.size()-1],nums[nums.size()-2]);   \
    \}\
\
\
    int rob(vector<int>& nums) \
    \{\
        if(nums.size()==0)\
            return 0;\
        else if(nums.size()==1)\
            return nums[0];\
        \
        vector<int> m1=nums;\
        m1.erase(m1.begin());\
        vector<int> m2=nums;\
        m2.pop_back();\
        \
        return max(rob1(m1), rob1(m2));\
    \}\
\};}