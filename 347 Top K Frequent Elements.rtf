{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh14980\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Given a non-empty array of integers, return the k most frequent elements.\
\
For example,\
Given [1,1,1,2,2,3] and k = 2, return [1,2].\
\
Note: \
You may assume k is always valid, 1 \uc0\u8804  k \u8804  number of unique elements.\
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.\
\
map!\
\
*/\
class Solution \{\
public:\
    vector<int> topKFrequent(vector<int>& nums, int k) \
    \{\
        map<int,int> one;\
        for (int i = 0; i < nums.size() ;i++)\
        \{\
            one[nums[i]]++;\
        \}\
        multimap<int,int> two;\
        for (auto it = one.begin(); it != one.end(); it++)\
        \{\
            two.insert(make_pair(it->second, it->first));\
        \}\
        vector<int> ret;\
        auto it = two.end();\
        it --;\
        for (; it != two.begin(), k > 0; it --, k --)\
        \{\
            ret.push_back(it->second);\
        \}\
        return ret;\
    \}\
\};}