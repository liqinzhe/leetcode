{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\
\
Calling next() will return the next smallest number in the BST.\
\
Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\
\
way-1:
\f1 \'bb\'e1\'b8\'c4\'b1\'e4
\f0 root
\f1 \'b5\'c4\'bd\'e1\'b9\'b9
\f0 \
\
way-2:
\f1 \'d3\'c3\'c1\'cb
\f0 stack
\f1 \'a3\'ac\'b2\'bb\'bb\'e1\'b8\'c4\'b1\'e4\'ca\'f7\'bd\'e1\'b9\'b9\'a1\'a3\'ba\'cd\'d6\'ae\'c7\'b0\'d2\'bb\'b8\'f6\'b1\'e9\'c0\'fa\'b6\'fe\'b2\'e6\'cb\'d1\'cb\'f7\'ca\'f7\'b5\'c4\'cc\'e2\'d2\'bb\'b8\'f6\'cb\'bc\'c2\'b7\'a1\'a3
\f0 \
\
\
\
*/\
/**\
 * Definition for binary tree\
 * struct TreeNode \{\
 *     int val;\
 *     TreeNode *left;\
 *     TreeNode *right;\
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) \{\}\
 * \};\
 */\
 \
 \
//way-1\
/*\
class BSTIterator \{\
public:\
    BSTIterator(TreeNode *root) \
    \{\
        this->root=root;    \
    \}\
\
    \
    bool hasNext() \
    \{\
        if(root)\
            return 1;\
        else\
            return 0;\
    \}\
\
    int next() \
    \{\
        if( hasNext() )\
        \{\
            int ret;\
            TreeNode *p=root;\
            if(!p->left)\
            \{\
                ret=p->val;\
                root=p->right;\
                return ret;\
            \}\
            \
            while(p->left->left)\
                p=p->left;\
            \
            ret=p->left->val;\
            p->left=p->left->right;\
            return ret;\
        \}\
        return -1;\
    \}\
    \
private:\
    TreeNode *root;\
\
\};\
*/\
\
//way-2\
\
class BSTIterator \{\
public:\
    BSTIterator(TreeNode *root) \
    \{\
        this->root=root; \
        push_stack(this->root);\
    \}\
    \
    void push_stack(TreeNode *node)\
    \{\
        while(node)\
        \{\
            m1.push(node);\
            node=node->left;\
        \}\
    \}\
    \
    \
    bool hasNext() \
    \{\
        return (root && !m1.empty()) ? 1 : 0;\
    \}\
\
    int next() \
    \{\
        TreeNode *p=m1.top();\
        m1.pop();\
        push_stack(p->right);\
        return p->val;\
    \}\
    \
    \
private:\
    TreeNode *root;\
    stack<TreeNode *> m1;\
    \
\};\
\
\
/**\
 * Your BSTIterator will be called like this:\
 * BSTIterator i = BSTIterator(root);\
 * while (i.hasNext()) cout << i.next();\
 */}