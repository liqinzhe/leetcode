{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;\red243\green235\blue0;}
{\*\expandedcolortbl;;\csgenericrgb\c95294\c92157\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww17680\viewh20720\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.\
\
For example,\
Given n = 3, your program should return all 5 unique BST's shown below.\
\
   1         3     3      2      1\
    \\       /     /      / \\      \\\
     3     2     1      1   3      2\
    /     /       \\                 \\\
   2     1         2                 3\
   \

\f1 \'d3\'c9\'d3\'da
\f0 1~n
\f1 \'ca\'c7\'c9\'fd\'d0\'f2\'c1\'d0\'a3\'ac\'d2\'f2\'b4\'cb\'bd\'a8\'c6\'f0\'c0\'b4\'b5\'c4\'ca\'f7\'cc\'ec\'c8\'bb\'be\'cd\'ca\'c7
\f0 BST
\f1 \'a1\'a3
\f0 \
\

\f1 \cf0 \cb2 \'b7\'d6\'d6\'ce\'b5\'c4\'cb\'bc\'cf\'eb\cf0 \cb1 \'a3\'ac\'d2\'c0\'b4\'ce\'d1\'a1\'d4\'f1\'b8\'f9\'bd\'da\'b5\'e3\'a3\'ac\'b6\'d4\'d7\'f3\'d3\'d2\'d7\'d3\'d0\'f2\'c1\'d0\'d4\'d9\'b7\'d6\'b1\'f0\'bd\'a8\'ca\'f7\'a1\'a3
\f0 \
\

\f1 \'d3\'c9\'d3\'da\'d7\'f3\'d3\'d2\'d7\'d3\'d0\'f2\'c1\'d0\'bd\'a8\'ca\'f7\'b5\'c4\'bd\'e1\'b9\'fb\'d2\'b2\'bf\'c9\'c4\'dc\'b2\'bb\'d6\'b9\'d2\'bb\'d6\'d6\'a3\'ac\'d0\'e8\'d2\'aa\'bf\'bc\'c2\'c7\'cb\'f9\'d3\'d0\'b4\'ee\'c5\'e4\'c7\'e9\'bf\'f6\'a1\'a3
\f0 \
\
vector<TreeNode *> left
\f1 \'b4\'fa\'b1\'ed\'cb\'f9\'d3\'d0
\f0 valid
\f1 \'d7\'f3\'d7\'d3\'ca\'f7\'a1\'a3
\f0 \
\
vector<TreeNode *> right
\f1 \'b4\'fa\'b1\'ed\'cb\'f9\'d3\'d0
\f0 valid
\f1 \'d3\'d2\'d7\'d3\'ca\'f7\'a1\'a3
\f0   \
   \
*/\
/**\
 * Definition for a binary tree node.\
 * struct TreeNode \{\
 *     int val;\
 *     TreeNode *left;\
 *     TreeNode *right;\
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) \{\}\
 * \};\
 */\
class Solution \{\
public:\
    vector<TreeNode*> guocheng(int begin, int end)\
    \{\
        vector<TreeNode*> ret;\
        if(begin > end)\
        \{\
            ret.push_back(NULL);\
        \}\
        else if(begin == end)\
        \{\
            ret.push_back( new TreeNode(begin) );\
        \}\
        else\
        \{\
            for(int i = begin;i <= end;i++)\
            \{\
                vector<TreeNode*> left = guocheng(begin, i-1);\
                vector<TreeNode*> right = guocheng(i+1, end);\
                for(int j = 0; j < left.size(); j++)\
                \{\
                    for(int k = 0; k < right.size(); k++)\
                    \{\
                        TreeNode *rr = new TreeNode(i);\
                        rr->left = left[j];\
                        rr->right = right[k];\
                        ret.push_back(rr);\
                    \}\
                \}\
            \}\
        \}\
        return ret;\
    \}\
  \
    vector<TreeNode*> generateTrees(int n) \
    \{ \
        if(n == 0)\
        \{\
            return vector<TreeNode*>();              \
        \}\
\
        return guocheng(1,n);\
    \}\
\};}