{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Compare two version numbers version1 and version2.\
If version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.\
\
You may assume that the version strings are non-empty and contain only digits and the . character.\
The . character does not represent a decimal point and is used to separate number sequences.\
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.\
\
Here is an example of version numbers ordering:\
\
0.1 < 1.1 < 1.2 < 13.37\
\
*/\
class Solution \{\
public:\
    vector<int> chuli(string v)\
    \{\
        vector<int> ret;\
        int k=0;\
        int all=0;\
        while(k<v.size())\
        \{\
            if(v[k]=='.')\
            \{    \
                ret.push_back(all);\
                all=0;\
            \} \
            else if(k==v.size()-1)\
            \{ \
                all=all*10+int(v[k])-48;\
                ret.push_back(all);\
            \}\
            else\
                all=all*10+int(v[k])-48;\
            k++;      \
        \}\
        return ret;\
    \}\
    \
    \
    \
    int compareVersion(string v1, string v2) \
    \{\
        if(v1==v2)\
            return 0;\
         \
        vector<int> vv1=chuli(v1);\
        vector<int> vv2=chuli(v2);\
         \
        int length=min(vv1.size(),vv2.size());\
        for(int i=0;i<length;i++)\
        \{\
            if(vv1[i]>vv2[i])\
                return 1;\
            else if(vv1[i]<vv2[i])    \
                return -1;\
        \}\
         \
         \
        if(length==vv1.size() && length==vv2.size())\
            return 0;\
        else if(length<vv1.size())        \
        \{\
            for(int i=length;i<vv1.size();i++)\
            \{\
                if(vv1[i]!=0)\
                    return 1;\
            \}        \
        \}\
        else\
        \{\
            for(int i=length;i<vv2.size();i++)\
            \{\
                if(vv2[i]!=0)\
                    return -1;\
            \}\
        \}\
        return 0;\
    \}\
\};}