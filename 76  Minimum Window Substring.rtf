{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\
\
For example,\
S = "ADOBECODEBANC"\
T = "ABC"\
Minimum window is "BANC".\
\
Note:\
If there is no such window in S that covers all characters in T, return the empty string "".\
\
If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\
\

\f1 \'b1\'be\'cc\'e2\'d3\'d0\'c4\'d1\'b6\'c8\'a1\'a3\'c1\'bd\'b8\'f6\'d6\'b8\'d5\'eb\'a3\'ac
\f0 map
\f1 \'a1\'a3
\f0 \

\f1 \'a3\'a8
\f0 1
\f1 \'a3\'a9
\f0 i
\f1 \'d6\'b8\'d5\'eb\'c9\'a8\'c3\'e8\'a3\'ac
\f0 tmap[s[i]]=0
\f1 \'cb\'b5\'c3\'f7\'d7\'d3\'b4\'ae\'c0\'ef\'b8\'d5\'ba\'c3\'d3\'d0\'d7\'e3\'b9\'bb\'b8\'f6
\f0 s[i]
\f1 \'a3\'ac
\f0 count++\

\f1 \'a3\'a8
\f0 2
\f1 \'a3\'a9\'b5\'b1
\f0 count=T.size()
\f1 \'ca\'b1\'a3\'ac
\f0 l
\f1 \'d6\'b8\'d5\'eb\'bf\'aa\'ca\'bc\'c9\'a8\'a3\'ac\'c9\'a8\'b5\'bd\'d2\'bb\'b8\'f6\'be\'cd
\f0 tmap[s[i]]++
\f1 \'a3\'ac\'d2\'f2\'ce\'aa
\f0 l
\f1 \'ca\'c7\'d7\'d3\'b4\'ae\'d7\'f3\'d6\'b8\'d5\'eb\'a3\'ac\'cb\'b5\'c3\'f7\'c8\'b1\'ca\'a7\'d2\'bb\'b8\'f6
\f0 s[i],
\f1 \'bf\'aa\'ca\'bc\'c8\'b1\'ca\'a7\'be\'cd\'ca\'c7\'d7\'d3\'b4\'ae\'bf\'aa\'ca\'bc\'b5\'c4\'ce\'bb\'d6\'c3\'a3\'ac\'b8\'fc\'d0\'c2\'b3\'a4\'b6\'c8
\f0 \
\
\
*/\
class Solution \{\
public:\
    string minWindow(string s, string t) \
    \{\
       map<char,int> tmap;\
       for(int i=0;i<t.size();i++)\
          tmap[t[i]]++;\
       \
       int count=0;//
\f1 \'b4\'e6\'c4\'bf\'b1\'ea\'d7\'d3\'b4\'ae\'d6\'d0\'c6\'a5\'c5\'e4\'c9\'cf\'b5\'c4\'b3\'a4\'b6\'c8
\f0 \
       int l=0;\
       int left;//
\f1 \'b4\'e6\'c4\'bf\'b1\'ea\'d7\'d3\'b4\'ae\'bf\'aa\'ca\'bc\'ce\'bb\'d6\'c3
\f0 \
       int length=s.size()+1;//
\f1 \'c4\'bf\'b1\'ea\'d7\'d3\'b4\'ae\'b3\'a4\'b6\'c8
\f0 \
       for(int i=0;i<s.size();i++)\
       \{\
           if(tmap.find(s[i])!=tmap.end())//
\f1 \'d7\'d3\'b4\'ae\'bf\'aa\'cd\'b7\'bf\'cf\'b6\'a8\'ca\'c7\'d4\'da
\f0 tmap
\f1 \'c0\'ef\'c3\'e6
\f0 \
           \{\
               tmap[s[i]]--;\
               if(tmap[s[i]]>=0)\
                   count++;\
               \
               while(count==t.size())\
               \{\
                   if(tmap.find(s[l])!=tmap.end())\
                   \{\
                       tmap[s[l]]++;\
                       if(tmap[s[l]]>0)//>0
\f1 \'b4\'fa\'b1\'ed\'bf\'aa\'ca\'bc\'c8\'b1\'ca\'a7\'a3\'ac\'cb\'b5\'c3\'f7\'d5\'d2\'b5\'bd\'c1\'cb\'d7\'d3\'b4\'ae\'b5\'c4\'bf\'aa\'cd\'b7
\f0 \
                       \{  \
                          count--;\
                          if(i-l+1<length)\
                          \{\
                             length=i-l+1; \
                             left=l;  \
                          \}    \
                       \}\
                   \}\
                   l++;//
\f1 \'d7\'d3\'b4\'ae\'d7\'f3\'b1\'df\'bd\'e7
\f0 ++\
               \}\
           \}\
       \}\
       if(length==s.size()+1)\
           return "";\
       else\
           return s.substr(left,length);   \
    \}\
\};}