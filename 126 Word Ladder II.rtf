{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\
\
Only one letter can be changed at a time\
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.\
For example,\
\
Given:\
beginWord = "hit"\
endWord = "cog"\
wordList = ["hot","dot","dog","lot","log","cog"]\
Return\
  [\
    ["hit","hot","dot","dog","cog"],\
    ["hit","hot","lot","log","cog"]\
  ]\
Note:\
Return an empty list if there is no such transformation sequence.\
All words have the same length.\
All words contain only lowercase alphabetic characters.\
You may assume no duplicates in the word list.\
You may assume beginWord and endWord are non-empty and are not the same.\
\
way-1:backtracking! TLE\'85\
\
way-2:\

\f1 \'bc\'c8\'c8\'bb\'ca\'c7\'c7\'f3\'d7\'ee\'b6\'cc\'c2\'b7\'be\'b6\'a3\'ac\'bf\'c9\'d2\'d4\'bf\'bc\'c2\'c7\'b6\'af\'b9\'e9\'bb\'f2\'b9\'e3\'cb\'d1\'a1\'a3\'d5\'e2\'b5\'c0\'cc\'e2\'b6\'d4\'d7\'d6\'b5\'e4\'d6\'b1\'bd\'d3\'bd\'f8\'d0\'d0\'b6\'af\'b9\'e9\'ca\'c7\'b2\'bb\'cf\'d6\'ca\'b5\'b5\'c4\'a3\'ac\'d2\'f2\'ce\'aa\'d7\'d6\'b5\'e4\'c0\'ef\'b5\'c4\'b5\'a5\'b4\'ca\'b7\'c7\'b3\'a3\'b6\'e0\'a1\'a3\'d6\'bb\'c4\'dc\'d1\'a1\'d4\'f1\'b9\'e3\'cb\'d1\'c1\'cb\'a1\'a3
\f0 \
\

\f1 \'cb\'bc\'c2\'b7\'d2\'b2\'b7\'c7\'b3\'a3\'d6\'b1\'b9\'db\'a3\'ac\'b4\'d3
\f0 start
\f1 \'bb\'f2
\f0 end
\f1 \'bf\'aa\'ca\'bc\'a3\'ac\'b2\'bb\'b6\'cf\'bc\'d3\'c8\'eb\'cb\'f9\'d3\'d0\'bf\'c9\'b5\'bd\'b4\'ef\'b5\'c4\'b5\'a5\'b4\'ca\'a3\'ac\'d6\'b1\'b5\'bd\'d7\'ee\'d6\'d5\'b5\'bd\'b4\'ef\'c1\'ed\'d2\'bb\'b6\'cb\'a1\'a3\'b1\'be\'d6\'ca\'c9\'cf\'b9\'e3\'b6\'c8\'d3\'c5\'cf\'c8\'b1\'e9\'c0\'fa\'cd\'bc\'a1\'a3
\f0 \
\

\f1 \'d0\'e8\'d2\'aa\'d7\'a2\'d2\'e2\'b5\'c4\'ca\'c7\'a3\'ac\'cd\'d8\'d5\'b9\'cf\'c2\'d2\'bb\'b8\'f6\'b5\'a5\'b4\'ca\'ca\'b1\'b2\'bb\'c4\'dc\'b6\'d4\'d7\'d6\'b5\'e4\'bd\'f8\'d0\'d0\'c3\'b6\'be\'d9\'a3\'ac\'d2\'f2\'ce\'aa\'d7\'d6\'b5\'e4\'c0\'ef\'b5\'c4\'b5\'a5\'b4\'ca\'cc\'ab\'b6\'e0\'a1\'a3\'d0\'d2\'ba\'c3\'b5\'a5\'b4\'ca\'b1\'be\'c9\'ed\'b6\'bc\'b2\'bb\'b3\'a4\'a3\'ac\'cb\'f9\'d2\'d4\'d6\'b1\'bd\'d3\'c3\'b6\'be\'d9\'b5\'a5\'b4\'ca\'cb\'f9\'d3\'d0\'bf\'c9\'c4\'dc\'b5\'c4\'b1\'e4\'d0\'ce\'a3\'ac\'bf\'b4\'bf\'b4\'d4\'da
\f0 dict
\f1 \'d6\'d0\'b3\'f6\'cf\'d6\'c3\'bb\'d3\'d0\'a1\'a3
\f0 \
\

\f1 \'b5\'b1\'c8\'bb\'bb\'b9\'b2\'bb\'d6\'b9\'d5\'e2\'d0\'a9\'a3\'ac\'c9\'cf\'c3\'e6\'b5\'c4\'d7\'f6\'b7\'a8\'c8\'d4\'c8\'bb\'bb\'e1\'b3\'ac\'ca\'b1\'a3\'ac\'d0\'e8\'d2\'aa\'cc\'ed\'bc\'d3\'bc\'f4\'d6\'a6\'b2\'df\'c2\'d4\'a3\'ba
\f0 \
\
1. 
\f1 \'c8\'e7\'b9\'fb\'c4\'b3\'b8\'f6\'b5\'a5\'b4\'ca\'d4\'da\'d2\'d4\'c7\'b0\'b1\'e9\'c0\'fa\'b9\'fd\'c1\'cb\'a3\'ac\'c4\'c7\'c3\'b4\'d2\'d4\'ba\'f3\'b6\'bc\'b2\'bb\'d3\'c3\'d4\'d9\'bf\'bc\'c2\'c7\'a3\'ac\'d2\'f2\'ce\'aa\'d6\'ae\'ba\'f3\'b1\'e9\'c0\'fa\'b5\'bd\'b5\'c4\'c2\'b7\'be\'b6\'d2\'bb\'b6\'a8\'b2\'bb\'ca\'c7\'d7\'ee\'b6\'cc\'b5\'c4
\f0 \
\
2. 
\f1 \'d4\'da\'b9\'e3\'cb\'d1\'b7\'a8\'cd\'d8\'d5\'b9\'cf\'c2\'d2\'bb\'c2\'d6\'b5\'a5\'b4\'ca\'ca\'b1\'a3\'ac\'d7\'a2\'d2\'e2\'c8\'a5\'d6\'d8
\f0 \
\

\f1 \'b4\'cb\'cd\'e2\'bb\'b9\'d0\'e8\'d2\'aa\'d7\'a2\'d2\'e2\'b5\'c4\'ca\'c7\'a3\'ac\'b2\'bb\'c4\'dc\'b0\'d1\'c3\'bf\'b8\'f6\'b5\'a5\'b4\'ca\'b5\'bd
\f0 start
\f1 \'bb\'f2
\f0 end
\f1 \'b5\'c4\'c2\'b7\'be\'b6\'b6\'bc\'b1\'a3\'b4\'e6\'cf\'c2\'c0\'b4\'a3\'ac\'c4\'c7\'d1\'f9\'c4\'da\'b4\'e6\'bb\'e1\'b1\'ac\'b5\'f4\'a1\'a3\'cb\'f9\'d2\'d4\'d2\'aa\'d1\'b9\'cb\'f5\'b1\'a3\'b4\'e6\'bd\'e1\'b9\'fb\'a3\'ac\'cd\'a8\'b3\'a3\'b5\'c4\'d7\'f6\'b7\'a8\'ca\'c7\'d3\'c3\'d2\'bb\'b8\'f6
\f0 map
\f1 \'b1\'a3\'b4\'e6\'b5\'b1\'c7\'b0\'b5\'a5\'b4\'ca\'cf\'c2\'d2\'bb\'b2\'bd\'ca\'c7\'ca\'b2\'c3\'b4\'b5\'a5\'b4\'ca\'a1\'a3\'c0\'fd\'c8\'e7
\f0 next[word] = \{next_word1, next_word2, next_word3...\}
\f1 \'a1\'a3\'d7\'ee\'ba\'f3\'b4\'d3
\f0 next[start]
\f1 \'bf\'aa\'ca\'bc\'d4\'d9\'b4\'ce\'ca\'b9\'d3\'c3\'b9\'e3\'b6\'c8\'d3\'c5\'cf\'c8\'cb\'d1\'cb\'f7\'b7\'a8\'b9\'b9\'d4\'ec\'b3\'f6\'cb\'f9\'d3\'d0\'bd\'e2\'a1\'a3
\f0 \
\

\f1 \'cb\'e3\'b7\'a8\'b2\'bb\'c4\'d1\'a3\'ac\'b5\'ab\'ca\'c7\'b1\'e0\'c2\'eb\'b7\'c7\'b3\'a3\'c8\'dd\'d2\'d7\'b3\'f6\'b4\'ed\'a3\'ac\'cb\'f9\'d2\'d4\'d7\'dc\'cc\'e5\'c9\'cf\'bb\'b9\'ca\'c7\'cd\'a6\'c4\'d1\'b5\'c4\'a1\'a3\'d7\'ee\'ba\'f3\'d4\'cb\'d0\'d0\'ca\'b1\'bc\'e4
\f0 640ms
\f1 \'a3\'ac\'bb\'b9\'ca\'c7\'d3\'d0\'cd\'a6\'b4\'f3\'d3\'c5\'bb\'af\'bf\'d5\'bc\'e4\'b5\'c4\'a1\'a3
\f0 \
\
 \
\

\f1 \'b4\'fa\'c2\'eb\'d0\'b4\'b5\'c4\'d3\'d0\'d0\'a9\'86\'aa\'e0\'c2\'a3\'ac
\f0 DFS
\f1 \'b2\'bb\'d2\'bb\'b6\'a8\'d2\'aa\'d3\'c3\'b6\'d3\'c1\'d0\'a3\'a8\'ce\'d2\'bb\'b9\'ca\'c7\'d3\'c3\'c1\'cb\'b6\'d3\'c1\'d0\'a3\'a9\'a3\'ac\'d5\'e2\'b5\'c0\'cc\'e2\'d3\'c3
\f0 unordered_set
\f1 \'b8\'fc\'ba\'c3\'a3\'ac\'b2\'bb\'d0\'e8\'d2\'aa\'d3\'c3\'b6\'ee\'cd\'e2\'b5\'c4\'ca\'fd\'be\'dd\'bd\'e1\'b9\'b9\'c8\'a5\'d6\'d8\'c1\'cb\'a1\'a3
\f0 \
\
http://www.cnblogs.com/boring09/p/4238381.html\
\
*/\
class Solution \{\
public:\
    int minlen;\
    \
    bool isclose(string a,string b)\
    \{\
        char temp;\
        for(int i=0;i<a.size();i++)\
        \{\
            if(a[i] == b[i])\
                continue;\
            else\
            \{\
                temp=a[i];\
                a[i]=b[i];\
                if(a == b)\
                    return 1;\
                a[i]=temp;\
            \}\
        \}\
        return 0;\
    \}\
    \
    void guocheng(vector<vector<string>> &ret, vector<string> m1, vector<string> wordList, string endWord)\
    \{\
        if( m1.size() > (minlen-1))\
            return;\
        \
        if( isclose(m1[m1.size()-1],endWord) )\
        \{\
            m1.push_back(endWord);\
            \
            if(m1.size() < minlen)\
            \{\
                ret.clear();\
            \}\
            minlen=m1.size();\
            ret.push_back(m1);\
            return;\
        \}\
        \
        if( m1.size() > (minlen-2))\
            return;\
        \
        for(int i=0;i<wordList.size();i++)\
        \{\
            if( isclose(m1[m1.size()-1], wordList[i]) )\
            \{\
                m1.push_back(wordList[i]);\
                vector<string> temp=wordList;\
                temp.erase(temp.begin()+i);\
                guocheng(ret, m1, temp, endWord);\
                m1.pop_back();\
            \}\
        \}\
    \}\
    \
    \
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) \
    \{\
        \
        //way-1\
        /*\
        vector<vector<string>> ret;\
        vector<string> m1(1,beginWord);\
        minlen=INT_MAX;\
        \
        if( find(wordList.begin(),wordList.end(),endWord) == wordList.end())\
            return ret;\
        \
        guocheng(ret, m1, wordList, endWord);\
        \
        return ret;\
        */\
        \
        //way-2\
        \
        \
        \
    \}\
\};}