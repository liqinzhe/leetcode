{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
There are two sorted arrays nums1 and nums2 of size m and n respectively.\
\
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\
\
Example 1:\
nums1 = [1, 3]\
nums2 = [2]\
\
The median is 2.0\
Example 2:\
nums1 = [1, 2]\
nums2 = [3, 4]\
\
The median is (2 + 3)/2 = 2.5\
\
way-1
\f1 \'a3\'ba\'b9\'e9\'b2\'a2\'c5\'c5\'d0\'f2
\f0  O(m+n)\
\
way-2:\

\f1 \'b7\'d6\'b6\'f8\'d6\'ce\'d6\'ae\'b5\'c4\'d2\'e2\'cb\'bc
\f0 ,
\f1 \'d6\'b8\'b5\'c4\'ca\'c7\'b7\'d6\'d6\'ce\'cb\'e3\'b7\'a8
\f0 .
\f1 \'b7\'d6\'d6\'ce\'cb\'e3\'b7\'a8\'ca\'c7\'bb\'f9\'d3\'da\'b6\'e0\'b7\'d6\'d6\'a6\'b5\'dd\'b9\'e9\'b5\'c4\'d2\'bb\'d6\'d6\'cb\'e3\'b7\'a8\'c9\'e8\'bc\'c6\'c4\'a3\'ca\'bd
\f0 .
\f1 \'b7\'d6\'d6\'ce\'cb\'e3\'b7\'a8\'b5\'dd\'b9\'e9\'b5\'d8\'b0\'d1\'d2\'bb\'b8\'f6\'b4\'f3\'ce\'ca\'cc\'e2\'b7\'d6\'bd\'e2\'ce\'aa\'b6\'e0\'b8\'f6\'c0\'e0\'d0\'cd\'cf\'e0\'cd\'ac\'b5\'c4\'d7\'d3\'ce\'ca\'cc\'e2
\f0 ,
\f1 \'d6\'b1\'b5\'bd\'d5\'e2\'d0\'a9\'d7\'d3\'ce\'ca\'cc\'e2\'d7\'e3\'b9\'bb\'b5\'c4\'bc\'f2\'b5\'a5\'c4\'dc\'b1\'bb\'d6\'b1\'bd\'d3\'bd\'e2\'be\'f6
\f0 .
\f1 \'d7\'ee\'ba\'f3\'b0\'d1\'d5\'e2\'d0\'a9\'d7\'d3\'ce\'ca\'cc\'e2\'b5\'c4\'bd\'e2\'bd\'e1\'ba\'cf\'c6\'f0\'c0\'b4\'be\'cd\'c4\'dc\'b5\'c3\'b5\'bd\'d4\'ad\'ca\'bc\'ce\'ca\'cc\'e2\'b5\'c4\'bd\'e2
\f0 .\
\
\
Assume that the number of elements in A and B are both larger than k/2, and if we compare the k/2-th smallest element in A(i.e. A[k/2-1]) and the k-th smallest element in B(i.e. B[k/2 - 1]), there are three results:\
(Becasue k can be odd or even number, so we assume k is even number here for simplicy. The following is also true when k is an odd number.)\
A[k/2-1] = B[k/2-1]\
A[k/2-1] > B[k/2-1]\
A[k/2-1] < B[k/2-1]\
if A[k/2-1] < B[k/2-1], that means all the elements from A[0] to A[k/2-1](i.e. the k/2 smallest elements in A) are in the range of k smallest elements in the union of A and B. Or, in the other word, A[k/2 - 1] can never be larger than the k-th smalleset element in the union of A and B.\
\
Why?\
\
We can use a proof by contradiction. Since A[k/2 - 1] is larger than the k-th smallest element in the union of A and B, then we assume it is the (k+1)-th smallest one. Since it is smaller than B[k/2 - 1], then B[k/2 - 1] should be at least the (k+2)-th smallest one. So there are at most (k/2-1) elements smaller than A[k/2-1] in A, and at most (k/2 - 1) elements smaller than A[k/2-1] in B.So the total number is k/2+k/2-2, which, no matter when k is odd or even, is surly smaller than k(since A[k/2-1] is the (k+1)-th smallest element). So A[k/2-1] can never larger than the k-th smallest element in the union of A and B if A[k/2-1]<B[k/2-1];\
Since there is such an important conclusion, we can safely drop the first k/2 element in A, which are definitaly smaller than k-th element in the union of A and B. This is also true for the A[k/2-1] > B[k/2-1] condition, which we should drop the elements in B.\
When A[k/2-1] = B[k/2-1], then we have found the k-th smallest element, that is the equal element, we can call it m. There are each (k/2-1) numbers smaller than m in A and B, so m must be the k-th smallest number. So we can call a function recursively, when A[k/2-1] < B[k/2-1], we drop the elements in A, else we drop the elements in B.\
\
\
We should also consider the edge case, that is, when should we stop?\
1. When A or B is empty, we return B[k-1]( or A[k-1]), respectively;\
2. When k is 1(when A and B are both not empty), we return the smaller one of A[0] and B[0]\
3. When A[k/2-1] = B[k/2-1], we should return one of them\
\
\
\
*/\
class Solution \{\
public:\
    double findkth(vector<int> num1, int m, vector<int> num2, int n, int k)\
    \{\
        //always assume that m is equal or smaller than n  \
        if(m > n)\
            return findkth(num2,n,num1,m,k);\
        if(m == 0)\
            return num2[k-1];\
        if(k == 1)\
            return min(num1[0], num2[0]);\
        \
        //divide k into two parts\
        int pa=min(k/2, m);\
        int pb=k - pa;\
        if(num1[pa-1] < num2[pb-1])\
        \{    \
            for(int i=1;i<=pa;i++)\
                num1.erase(num1.begin());\
            return findkth(num1,m-pa,num2,n,k-pa);\
        \}\
        else if(num1[pa-1] > num2[pb-1])\
        \{\
            for(int i=1;i<=pb;i++)\
                num2.erase(num2.begin());\
            return findkth(num1,m,num2,n-pb,k-pb);\
        \}\
        else\
            return num1[pa-1];\
    \}\
    \
    \
    double findMedianSortedArrays(vector<int>& num1, vector<int>& num2) \
    \{\
        //way-1\
        /*\
        int l1=nums1.size();\
        int l2=nums2.size();\
        int k1=0;\
        int k2=0;\
       \
        vector<int> contain; \
        while(k1<l1 && k2<l2)\
        \{\
            if(nums1[k1]<nums2[k2])\
            \{\
                contain.push_back(nums1[k1]);\
                k1++;\
            \}\
            else\
            \{\
                contain.push_back(nums2[k2]);\
                k2++; \
            \}\
        \}\
        if(k1==l1)\
        \{\
            for(int i=k2;i<l2;i++)\
                contain.push_back(nums2[i]);\
        \}\
        if(k2==l2)\
        \{\
            for(int i=k1;i<l1;i++)\
                contain.push_back(nums1[i]);\
        \}\
       \
        int k=contain.size();\
       \
        if(k%2==1)\
            return contain[(k-1)/2]; \
        else\
            return (double(contain[k/2]+contain[k/2-1])/2);\
        */\
        \
        //way-2\
        int total=num1.size()+num2.size(); \
        if(total%2==1)\
            return findkth(num1,num1.size(),num2,num2.size(),total/2+1);\
        else\
            return (findkth(num1,num1.size(),num2,num2.size(),total/2+1) + findkth(num1,num1.size(),num2,num2.size(),total/2))/2;\
    \}\
\};}