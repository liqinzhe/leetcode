{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww34320\viewh13640\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\
\
get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\
\
Follow up:\
Could you do both operations in O(1) time complexity?\
\
Example:\
\
LRUCache cache = new LRUCache( 2 );\
\
cache.put(1, 1);\
cache.put(2, 2);\
cache.get(1);       // returns 1\
cache.put(3, 3);    // evicts key 2\
cache.get(2);       // returns -1 (not found)\
cache.put(4, 4);    // evicts key 1\
cache.get(1);       // returns -1 (not found)\
cache.get(3);       // returns 3\
cache.get(4);       // returns 4\
\
get
\f1 \'b2\'d9\'d7\'f7\'a3\'ba
\f0 \
1/
\f1 \'b7\'b5\'bb\'d8
\f0 map
\f1 \'d6\'d0
\f0 key
\f1 \'b6\'d4\'d3\'a6\'b5\'c4
\f0 value
\f1 \'a3\'bb
\f0 \
2/
\f1 \'cd\'ac\'ca\'b1\'d0\'e8\'d2\'aa\'b8\'fc\'d0\'c2
\f0 list
\f1 \'d6\'d0
\f0 key
\f1 \'b5\'c4\'ce\'bb\'d6\'c3\'a3\'ac\'bd\'ab
\f0 key
\f1 \'b7\'c5\'d6\'c3\'d4\'da
\f0 list
\f1 \'d6\'d0\'d7\'ee\'bd\'fc\'b1\'bb\'b7\'c3\'ce\'ca\'b5\'c4\'ce\'bb\'d6\'c3\'c9\'cf(\'d7\'ee\'d7\'f3\'b1\'df\'a3\'ac\'cd\'b7\'b6\'cb)\
	\'b8\'fc\'d0\'c2\'b2\'d9\'d7\'f7\'cd\'ac\'d1\'f9\'d0\'e8\'d2\'aa\'c1\'bd\'b2\'bf\'c0\'b4\'cd\'ea\'b3\'c9\'a3\'ba
\f0 1
\f1 \'a3\'ba\'c9\'be\'b3\'fd
\f0 list
\f1 \'d6\'d0\'d4\'ad\'c0\'b4\'b5\'c4
\f0 key
\f1 \'a3\'bb
\f0 2
\f1 \'a3\'ba\'bd\'ab
\f0 key
\f1 \'b2\'e5\'c8\'eb
\f0 list
\f1 \'ca\'d7\'b6\'cb\'a1\'a3
\f0 \
\
set
\f1 \'b2\'d9\'d7\'f7\'a3\'ba
\f0 \
1/
\f1 \'ca\'d7\'cf\'c8\'c5\'d0\'b6\'cf\'d2\'aa\'b2\'e5\'c8\'eb\'b5\'c4
\f0 key
\f1 \'ca\'c7\'b7\'f1\'b4\'e6\'d4\'da
\f0 map
\f1 \'d6\'d0\'a3\'ac\'c8\'e7\'b9\'fb\'b4\'e6\'d4\'da\'b5\'c4\'bb\'b0\'a3\'ac\'d6\'bb\'d0\'e8\'d2\'aa\'b8\'fc\'d0\'c2
\f0 map
\f1 \'d6\'d0\'b6\'d4\'d3\'a6\'b5\'c4
\f0 value
\f1 \'a3\'ac\'cd\'ac\'ca\'b1\'b8\'fc\'d0\'c2
\f0 list
\f1 \'d6\'d0
\f0 key
\f1 \'b5\'c4\'ce\'bb\'d6\'c3\'a3\'bb
\f0 \
2/
\f1 \'c8\'e7\'b9\'fb
\f0 key
\f1 \'b2\'bb\'b4\'e6\'d4\'da
\f0 map
\f1 \'d6\'d0\'a3\'ac\'c4\'c7\'c3\'b4\'d0\'e8\'d2\'aa\'c5\'d0\'b6\'cf
\f0 map
\f1 \'c8\'dd\'c1\'bf\'ca\'c7\'b7\'f1\'d2\'d1\'c2\'fa\'a3\'ac\'c8\'e7\'b9\'fb\'c2\'fa\'c1\'cb\'a3\'ac\'be\'cd\'d0\'e8\'d2\'aa\'b4\'d3
\f0 map
\f1 \'d6\'d0\'c9\'be\'b3\'fd\'d2\'bb\'b8\'f6\'d4\'aa\'cb\'d8\'a3\'ac\'d5\'e2\'ca\'b1
\f0 list
\f1 \'be\'cd\'c5\'c9\'c9\'cf\'d3\'c3\'b3\'a1\'c1\'cb\'a3\'ac\'d2\'f2\'ce\'aa\'d7\'ee\'bd\'fc\'ca\'b9\'d3\'c3\'b5\'c4
\f0 key
\f1 \'ce\'bb\'d3\'da
\f0 list
\f1 \'b5\'c4\'ca\'d7\'b6\'cb\'a3\'ac\'c4\'c7\'c3\'b4\'d7\'ee\'be\'c3\'ce\'b4\'ca\'b9\'d3\'c3\'b5\'c4\'d4\'aa\'cb\'d8\'be\'cd\'ce\'bb\'d3\'da
\f0 list
\f1 \'ce\'b2\'b6\'cb\'a3\'ac\'bf\'c9\'d2\'d4\'b4\'d3
\f0 list
\f1 \'d6\'d0\'c8\'a1\'b3\'f6\'d7\'ee\'be\'c3\'ce\'b4\'ca\'b9\'d3\'c3\'b5\'c4
\f0 key
\f1 \'a3\'ac\'cd\'ac\'ca\'b1\'c9\'be\'b3\'fd
\f0 map
\f1 \'d6\'d0\'b6\'d4\'d3\'a6\'b5\'c4
\f0 key
\f1 \'ba\'cd
\f0 value
\f1 \'a1\'a3
\f0 \
3/
\f1 \'c8\'bb\'ba\'f3\'bd\'ab\'ca\'fd\'be\'dd\'b2\'e5\'c8\'eb
\f0 map
\f1 \'ba\'cd
\f0 list
\f1 \'d6\'d0\'a1\'a3
\f0 \
\

\f1 \'d7\'a2\'d2\'e2\'d2\'aa\'b5\'e3\'a3\'ba
\f0 \
1
\f1 \'a1\'a2
\f0 list
\f1 \'d7\'ee\'ba\'f3\'d2\'bb\'b8\'f6\'d4\'aa\'cb\'d8
\f0  s.back()\
2
\f1 \'a1\'a2
\f0 list
\f1 \'ca\'c7\'b2\'e5\'c8\'eb\'c9\'be\'b3\'fd\'d7\'ee\'bf\'ec\'b5\'c4
\f0 STL
\f1 \'a3\'ac\'cc\'d8\'b5\'e3\'ca\'c7\'bf\'c9\'d2\'d4\'c1\'bd\'b6\'cb\'b2\'e5\'c8\'eb\'c9\'be\'b3\'fd\'a1\'a3
\f0 \
\
*/\
class LRUCache \{\
public:\
    LRUCache(int capacity) \
    \{\
        this->capacity = capacity;\
    \}\
    \
    int get(int key) \
    \{\
        auto it = datas.find(key);\
        if ( it != datas.end() )\
        \{\
            update(key);\
            return it->second;\
        \}\
        else\
            return -1;\
    \}\
    \
    void put(int key, int value) \
    \{\
        int length = datas.size();  \
        auto it = datas.find(key);  \
        if(it != datas.end())  \
        \{  \
            it->second = value;  \
            update(key);  \
        \}  \
        else  \
        \{  \
            if (length >= capacity)  \
            \{  \
                datas.erase(s.back());  \
                s.pop_back();  \
            \}  \
            s.push_front(key);  \
            datas[key] = value;\
        \}\
    \}\
    \
private:\
    \
    map<int, int> datas;\
    int capacity;\
    list<int> s;\
    \
    void update(int key)\
    \{\
        s.remove(key);\
        s.push_front(key);\
    \}\
\};\
\
/**\
 * Your LRUCache object will be instantiated and called as such:\
 * LRUCache obj = new LRUCache(capacity);\
 * int param_1 = obj.get(key);\
 * obj.put(key,value);\
 */}