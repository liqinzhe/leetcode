{\rtf1\ansi\ansicpg936\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\
\
You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\
\
Example:\
Given 1->2->3->4->5->NULL,\
return 1->3->5->2->4->NULL.\
\
Note:\
The relative order inside both the even and odd groups should remain as it was in the input. \
The first node is considered odd, the second node even and so on ...\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 {{\NeXTGraphic 2017-4-27 ä¸‹åˆ3.17 æ‹æ‘„çš„ç…§ç‰‡.jpg \width10140 \height7400
}¬}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
*/\
/**\
 * Definition for singly-linked list.\
 * struct ListNode \{\
 *     int val;\
 *     ListNode *next;\
 *     ListNode(int x) : val(x), next(NULL) \{\}\
 * \};\
 */\
class Solution \{\
public:\
    ListNode* oddEvenList(ListNode* head) \
    \{\
        if(!head || !head->next || !head->next->next)\
            return head;\
        \
        ListNode* last=head;\
        \
        while(last->next)\
        \{\
            last=last->next;\
        \}\
        \
        ListNode* p=last;\
        ListNode*begin=head;\
        ListNode*q;\
        while(begin!=last)\
        \{\
            q=begin->next;\
            if(q==last)\
                last=last->next;\
            begin->next=q->next;\
            q->next=NULL;\
            p->next=q;\
            p=q;\
            begin=begin->next;\
        \}\
      \
        return head;    \
    \}\
\};}